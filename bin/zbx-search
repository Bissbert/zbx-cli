#!/usr/bin/env bash
set -euo pipefail
# shellcheck disable=SC1007,SC2015,SC1090,SC1091

SD="$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)"; PATH="$SD:$PATH"
# shellcheck source=bin/log-lib
. "$SD/log-lib"
# shellcheck source=bin/zbx-lib
. "$SD/zbx-lib"

usage() {
  cat <<'EOF'
Usage: zbx search <entity> <pattern> [options]

Search Zabbix entities (LIKE by default).

Details:

Entities:
  hosts         Search host "host" or "name" fields
  hostgroups    Search host group names
  templates     Search template names
  items         Search item names or keys (optionally by host)
  triggers      Search trigger descriptions (optionally by host)
  problems      Search current problem names
  macros        Search macros on a host (requires --host)

Options:
  --host HOST            Restrict to a specific host (items/triggers/macros)
  --like                 Use Zabbix API substring search (default)
  --regex                Use client-side regex (case-insensitive)
  --key                  For items: search by item key_ instead of name
  --limit N              Limit number of API results (default: 500)
  --format {tsv|csv|json}  Output format (default: tsv)
  --headers              Print a header row (tsv/csv only)
  --json                 Alias for --format json
  -h, --help             This help

Notes:
- Default matching uses API-side substring search (.search = { field: "pattern" }).
- `--regex` switches to client-side regex (case-insensitive) via jq `test()`.
- TSV columns vary by entity; fields are chosen to be script-friendly.
EOF
}

# -------- arg parsing --------
[ $# -lt 1 ] && { usage; exit 2; }
case "${1:-}" in
  -h|--help) usage; exit 0 ;;
esac

entity="${1:-}"; shift || true
[ $# -lt 1 ] && { log_error "Missing <pattern>"; usage; exit 2; }
pattern="${1:-}"; shift || true

HOST=""; LIKE=1; REGEX=0; KEYMODE=0; LIMIT=500; FORMAT=tsv; HEADERS=0
while [ $# -gt 0 ]; do
  case "$1" in
    --host) HOST="${2:-}"; shift ;;
    --like) LIKE=1; REGEX=0 ;;
    --regex) LIKE=0; REGEX=1 ;;
    --key) KEYMODE=1 ;;
    --limit) LIMIT="${2:-500}"; shift ;;
    --format) FORMAT="${2:-tsv}"; shift ;;
    --headers) HEADERS=1 ;;
    --json) FORMAT=json ;;
    # Global flags (accepted here as well for robustness)
    --insecure) export ZABBIX_VERIFY_TLS=0 ;;
    --cacert) export ZABBIX_CA_CERT="${2:-}"; shift ;;
    --capath) export ZABBIX_CA_PATH="${2:-}"; shift ;;
    -h|--help) usage; exit 0 ;;
    *) log_error "Unknown option: $1"; usage; exit 2 ;;
  esac
  shift || true
done

# Helpers
_ci_regex() { jq -r --arg re "$pattern" 'map(select((. // "") | test($re; "i")))' ; }

limit_param() { jq -n --argjson limit "$LIMIT" '{limit:$limit}'; }

# In LIKE mode, support simple glob-like inputs by stripping '*' and '?'
like_pat="$pattern"
if [ "$LIKE" -eq 1 ]; then
  if printf '%s' "$like_pat" | grep -q '[*?]'; then
    stripped="$(printf '%s' "$like_pat" | tr -d '*?' )"
    if [ -n "$stripped" ]; then
      log_info "Interpreting glob pattern '$like_pat' as substring '$stripped'"
      like_pat="$stripped"
    fi
  fi
fi


# If regex mode is active, validate the pattern early and hint on glob usage
if [ "$REGEX" -eq 1 ]; then
  if ! jq -n --arg re "$pattern" '"" | test($re; "i")' >/dev/null 2>&1; then
    log_error "Invalid regex: $pattern"
    log_info "Hint: use --like for glob/substring patterns (e.g., '*PC*')."
    exit 2
  fi
fi

# Resolve hostid if HOST provided
HOSTID=""
if [ -n "$HOST" ]; then
  HOSTID="$(jq -n --arg host "$HOST" '{filter:{host:$host}, output:["hostid"]}' \
    | zbx_call host.get | jq -r '.result[0].hostid // empty')"
  [ -z "$HOSTID" ] && { log_error "Host not found: $HOST"; exit 1; }
fi

# -------- entity handlers --------
case "$entity" in
  hosts)
    base='{"output":["hostid","host","name"],"sortfield":"name"}'
    req="$(printf '%s' "$base" | jq --argjson limit "$LIMIT" '.limit=$limit')"

    if [ "$LIKE" -eq 1 ]; then
      # Prefer API-side LIKE on both host and name fields
      req="$(jq --arg p "$like_pat" '.search = {host:$p, name:$p}' <<<"$req")"
    fi

    res="$(printf '%s' "$req" | zbx_call host.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["hostid","host","name"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.hostid, .host, .name])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '
        .result | map(select( ((.host // "") | test($re; "i")) or ((.name // "") | test($re; "i")) ))
        | map([.hostid,.host,.name])
      ' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  hostgroups)
    req='{"output":["groupid","name"],"sortfield":"name"}'
    req="$(jq --argjson limit "$LIMIT" '.limit=$limit' <<<"$req")"
    if [ "$LIKE" -eq 1 ]; then
      req="$(jq --arg p "$like_pat" '.search = {name:$p}' <<<"$req")"
    fi
    res="$(printf '%s' "$req" | zbx_call hostgroup.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["groupid","name"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.groupid, .name])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '.result | map(select((.name // "") | test($re; "i"))) | map([.groupid,.name])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  templates)
    req='{"output":["templateid","name"],"sortfield":"name"}'
    req="$(jq --argjson limit "$LIMIT" '.limit=$limit' <<<"$req")"
    if [ "$LIKE" -eq 1 ]; then
      req="$(jq --arg p "$like_pat" '.search = {name:$p}' <<<"$req")"
    fi
    res="$(printf '%s' "$req" | zbx_call template.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["templateid","name"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.templateid, .name])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '.result | map(select((.name // "") | test($re; "i"))) | map([.templateid,.name])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  items)
    field="name"; [ "$KEYMODE" -eq 1 ] && field="key_"
    base='{"output":["itemid","name","key_","hostid","value_type"],"sortfield":"name"}'
    req="$(printf '%s' "$base" | jq '.')"
    if [ -n "$HOSTID" ]; then
      req="$(jq --arg hid "$HOSTID" '.hostids = [$hid]' <<<"$req")"
    fi
    # Apply API-side LIKE if requested
    if [ "$LIKE" -eq 1 ]; then
      req="$(jq --arg f "$field" --arg p "$like_pat" '.search = {($f): $p}' <<<"$req")"
    fi
    req="$(jq --argjson limit "$LIMIT" '.limit = $limit' <<<"$req")"

    res="$(printf '%s' "$req" | zbx_call item.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["itemid","hostid","key_","name"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.itemid, .hostid, .key_, .name])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" --arg field "$field" '.result | map(select((.[ $field ] // "") | test($re; "i"))) | map([.itemid,.hostid,.key_,.name])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  triggers)
    base='{"output":["triggerid","description","priority","status","hostid"],"sortfield":"description"}'
    req="$(printf '%s' "$base" | jq '.')"
    if [ -n "$HOSTID" ]; then
      req="$(jq --arg hid "$HOSTID" '.hostids = [$hid]' <<<"$req")"
    fi
    if [ "$LIKE" -eq 1 ]; then
      req="$(jq --arg p "$like_pat" '.search = {description: $p}' <<<"$req")"
    fi
    req="$(jq --argjson limit "$LIMIT" '.limit = $limit' <<<"$req")"

    res="$(printf '%s' "$req" | zbx_call trigger.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["triggerid","hostid","priority","status","description"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.triggerid, .hostid, .priority, .status, .description])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '.result | map(select((.description // "") | test($re; "i"))) | map([.triggerid,.hostid,.priority,.status,.description])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  problems)
    # Only current/recent problems; request only needed fields
    base='{"recent":"true","sortfield":"eventid","sortorder":"DESC","output":["eventid","name","severity","acknowledged","clock"]}'
    req="$(printf '%s' "$base" | jq '.')"
    if [ "$LIKE" -eq 1 ]; then
      req="$(jq --arg p "$like_pat" '.search = {name:$p}' <<<"$req")"
    fi
    res="$(printf '%s' "$req" | zbx_call problem.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["eventid","name","severity","acknowledged","clock"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c '.result | map([.eventid,.name,.severity,.acknowledged,.clock])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '.result | map(select((.name // "") | test($re; "i"))) | map([.eventid,.name,.severity,.acknowledged,.clock])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  macros)
    [ -n "$HOSTID" ] || { log_error "macros search requires --host"; exit 2; }
    req="$(jq -n --arg hid "$HOSTID" '{hostids:[$hid]}' )"
    res="$(printf '%s' "$req" | zbx_call usermacro.get)"
    if [ "$FORMAT" = "json" ]; then jq '.result' <<<"$res"; exit 0; fi
    headers_json='["macro","value"]'
    if [ "$LIKE" -eq 1 ]; then
      rows="$(jq -c --arg p "$like_pat" '.result | map(select((.macro // "") | contains($p) or (.value // "") | contains($p))) | map([.macro,.value])' <<<"$res")"
    else
      rows="$(jq -c --arg re "$pattern" '.result | map(select((.macro // "") | test($re; "i") or (.value // "") | test($re; "i"))) | map([.macro,.value])' <<<"$res")"
    fi
    zbx_format_rows "$FORMAT" "$headers_json" "$rows" "$HEADERS"
  ;;

  *)
    log_error "Unknown entity: $entity"
    usage
    exit 2
  ;;
esac
