#!/usr/bin/env bash
set -euo pipefail

SD="$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)"; PATH="$SD:$PATH"

# ---- inline minimal logging (so zbx-config works even if log-lib isn't on PATH) ----
log_error(){ echo "[ERROR] $*" >&2; }
log_warn(){  echo "[WARN ] $*" >&2; }
log_info(){  echo "[INFO ] $*" >&2; }

# ---- config resolution (mirrors zbx-lib) ------------------------------------
_find_config() {
  local try
  if [ -n "${ZBX_CONFIG:-}" ] && [ -f "$ZBX_CONFIG" ]; then printf '%s\n' "$ZBX_CONFIG"; return 0; fi
  try="$SD/../config.sh"; [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  try="$PWD/config.sh";   [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  try="${XDG_CONFIG_HOME:-$HOME/.config}/zbx/config.sh"; [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  try="/etc/zbx/config.sh"; [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  return 1
}

# Choose target path by scope
_target_by_scope() {
  case "$1" in
    project)
      if [ -w "$PWD" ]; then printf '%s\n' "$PWD/config.sh"; return; else log_error "Not writable: $PWD"; exit 1; fi ;;
    user)
      local p="${XDG_CONFIG_HOME:-$HOME/.config}/zbx/config.sh"; mkdir -p "$(dirname "$p")"; printf '%s\n' "$p";;
    system)
      local p="/etc/zbx/config.sh"; sudo mkdir -p /etc/zbx >/dev/null 2>&1 || true; printf '%s\n' "$p";;
    auto|*)
      if [ -w "$PWD" ]; then printf '%s\n' "$PWD/config.sh"; else _target_by_scope user; fi ;;
  esac
}

OVR_BEGIN="# >>> zbx-config overrides >>>"
OVR_END="# <<< zbx-config overrides <<<"

usage() {
  cat <<'EOF'
Usage:
  zbx config list
  zbx config get VAR [--raw]
  zbx config set VAR VALUE [--scope {auto|project|user|system}]
  zbx config unset VAR [--scope {auto|project|user|system}]
  zbx config init [--scope {auto|project|user|system}]
  zbx config edit
  zbx config path

Notes:
- Overrides live in a managed block at the top of the file and take precedence.
- Default scope is `auto`: project if writable, else user (~/.config/zbx/config.sh).
- Set ZBX_CONFIG=/path/to/file to force a specific config file for all commands.
EOF
}

shell_escape(){ printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'; }

ensure_file() { local f="$1"; [ -f "$f" ] && return 0; mkdir -p "$(dirname "$f")"; cat >"$f" <<'CFG'
# zbx-toolkit config
: "${ZABBIX_URL:=https://zabbix.example.com/api_jsonrpc.php}"
: "${ZABBIX_USER:=apiuser}"
: "${ZABBIX_PASS:=apipassword}"
: "${ZABBIX_API_TOKEN:=}"
: "${ZABBIX_VERIFY_TLS:=1}"
: "${ZABBIX_TOKEN_FILE:=.zabbix_session.token}"
: "${ZABBIX_CURL_TIMEOUT:=25}"
CFG
log_info "Created $f"
}

ensure_block() {
  local f="$1"
  if ! grep -qF "$OVR_BEGIN" "$f" 2>/dev/null; then
    tmp="$(mktemp)"
    { echo "$OVR_BEGIN"; echo "$OVR_END"; echo; cat "$f"; } >"$tmp"
    mv "$tmp" "$f"
    log_info "Initialised override block in $f"
  fi
}

write_override() {
  local f="$1" var="$2" val="$3" esc; esc="$(shell_escape "$val")"
  ensure_block "$f"
  tmp="$(mktemp)"
  awk -v begin="$OVR_BEGIN" -v end="$OVR_END" -v var="$var" -v line="export "var"=\""$esc"\"" '
    BEGIN{inblk=0; done=0}
    {
      if ($0 == begin) {print; inblk=1; next}
      if ($0 == end)   { if (inblk && !done) print line; print; inblk=0; next }
      if (inblk && $0 ~ ("^[[:space:]]*export[[:space:]]+"var"=")) { if(!done){print line; done=1}; next }
      print
    }' "$f" >"$tmp"
  mv "$tmp" "$f"
}

remove_override() {
  local f="$1" var="$2"
  ensure_block "$f"
  tmp="$(mktemp)"
  awk -v begin="$OVR_BEGIN" -v end="$OVR_END" -v var="$var" '
    BEGIN{inblk=0}
    {
      if ($0 == begin) {print; inblk=1; next}
      if ($0 == end)   {print; inblk=0; next}
      if (inblk && $0 ~ ("^[[:space:]]*export[[:space:]]+"var"=")) next
      print
    }' "$f" >"$tmp"
  mv "$tmp" "$f"
}

get_effective() { local var="$1" cfg; cfg="$(_find_config || true)"; ( set -a; [ -n "$cfg" ] && . "$cfg"; printf '%s' "${!var-}" ); }

maybe_redact() {
  local var="$1" val="$2" raw="${3:-0}"
  [ "$raw" -eq 1 ] && { printf '%s\n' "$val"; return; }
  case "$var" in ZABBIX_PASS|ZABBIX_API_TOKEN|PHPIPAM_APP_TOKEN)
    [ -n "$val" ] && { printf '%s***\n' "$(printf '%s' "$val" | cut -c1-3)"; } || printf '\n'
    ;; *) printf '%s\n' "$val" ;; esac
}

cmd="${1:-}"; [ -z "$cmd" ] && { usage; exit 2; }; shift || true

case "$cmd" in
  -h|--help|help) usage ;;

  path)
    if cfg="$(_find_config)"; then echo "$cfg"; else echo "(no config found)"; fi
    ;;

  init)
    scope="${1:-}"; [ "$scope" = "--scope" ] && { scope="${2:-auto}"; shift 2; } || scope="auto"
    target="$(_target_by_scope "$scope")"
    ensure_file "$target"; ensure_block "$target"
    echo "$target"
    ;;

  edit)
    cfg="$(_find_config || true)"
    if [ -z "${cfg:-}" ]; then cfg="$(_target_by_scope auto)"; ensure_file "$cfg"; ensure_block "$cfg"; fi
    "${EDITOR:-vi}" "$cfg"
    ;;

  list)
    cfg="$(_find_config || true)"; [ -n "${cfg:-}" ] || { echo "(no config found)"; exit 0; }
    for v in ZABBIX_URL ZABBIX_USER ZABBIX_PASS ZABBIX_API_TOKEN ZABBIX_VERIFY_TLS ZABBIX_CURL_TIMEOUT ZABBIX_TOKEN_FILE; do
      printf '%s=' "$v"; maybe_redact "$v" "$(get_effective "$v")" 0
    done
    ;;

  get)
    [ $# -ge 1 ] || { log_error "Usage: zbx config get VAR [--raw]"; exit 2; }
    var="$1"; shift || true
    RAW=0; [ "${1:-}" = "--raw" ] && RAW=1
    maybe_redact "$var" "$(get_effective "$var")" "$RAW"
    ;;

  set)
    [ $# -ge 2 ] || { log_error "Usage: zbx config set VAR VALUE [--scope ...]"; exit 2; }
    var="$1"; shift
    # collect VALUE possibly with spaces, until optional --scope
    val_parts=()
    while [ $# -gt 0 ] && [ "$1" != "--scope" ]; do val_parts+=("$1"); shift; done
    val="${val_parts[*]:-}"
    scope="auto"; [ "${1:-}" = "--scope" ] && { scope="${2:-auto}"; shift 2; }
    target="$(_target_by_scope "$scope")"
    ensure_file "$target"; write_override "$target" "$var" "$val"
    echo "$target"
    ;;

  unset)
    [ $# -ge 1 ] || { log_error "Usage: zbx config unset VAR [--scope ...]"; exit 2; }
    var="$1"; shift || true
    scope="auto"; [ "${1:-}" = "--scope" ] && { scope="${2:-auto}"; shift 2; }
    target="$(_target_by_scope "$scope")"
    ensure_file "$target"; remove_override "$target" "$var"
    echo "$target"
    ;;

  *)
    log_error "Unknown subcommand: $cmd"; usage; exit 2 ;;
esac
