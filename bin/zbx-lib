#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)"
PATH="$SCRIPT_DIR:$PATH"

# If executed directly (not sourced) with -h/--help, print a short notice.
if [ "${BASH_SOURCE[0]-}" = "$0" ]; then
  case "${1:-}" in
    -h|--help)
      cat <<'EOF'
Internal library for zbx subcommands.
Not intended to be executed directly.
Provides config discovery, auth, and zbx_call helpers.
EOF
      exit 0 ;;
  esac
fi

# ---- Config discovery -------------------------------------------------------
_zbx_find_config() {
  local try
  # 1) explicit
  if [ -n "${ZBX_CONFIG:-}" ] && [ -f "$ZBX_CONFIG" ]; then
    printf '%s\n' "$ZBX_CONFIG"; return 0
  fi
  # 2) current working directory (interactive usage takes precedence)
  try="$PWD/config.sh";           [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  # 3) repo-local (when running from the project tree)
  try="$SCRIPT_DIR/../config.sh"; [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  # 4) user config (XDG)
  try="${XDG_CONFIG_HOME:-$HOME/.config}/zbx/config.sh"
  [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  # 5) system config
  try="/etc/zbx/config.sh";       [ -f "$try" ] && { printf '%s\n' "$try"; return 0; }
  # none found
  return 1
}

if _cfg="$(_zbx_find_config)"; then
  # shellcheck source=/dev/null
  . "$_cfg"
  export ZBX_CONFIG_ACTIVE="$_cfg"
else
  # no config is fine; defaults below will still apply
  export ZBX_CONFIG_ACTIVE=""
fi

# ---- Defaults (only if not set by env/config) -------------------------------
: "${ZABBIX_URL:=https://zabbix.example.com/api_jsonrpc.php}"
: "${ZABBIX_USER:=apiuser}"
: "${ZABBIX_PASS:=apipassword}"
: "${ZABBIX_API_TOKEN:=}"
: "${ZABBIX_VERIFY_TLS:=1}"
# Default token file to XDG state (fallback handled in _zbx_read_session_token)
: "${ZABBIX_TOKEN_FILE:=${XDG_STATE_HOME:-$HOME/.local/state}/zbx/session.token}"
: "${ZABBIX_SESSION_TTL:=1800}"
: "${ZABBIX_CURL_TIMEOUT:=25}"
# Optional TLS settings
: "${ZABBIX_CA_CERT:=}"
: "${ZABBIX_CA_PATH:=}"

# ---- Minimal logger fallbacks (overridden if log-lib is sourced first) ------
log_error(){ echo "[ERROR] $*" >&2; }
log_warn(){  echo "[WARN ] $*" >&2; }
log_info(){  echo "[INFO ] $*" >&2; }
log_debug(){ [ "${LOG_LEVEL:-}" = "debug" ] && echo "[DEBUG] $*" >&2; }

# ---- Dependency checks ------------------------------------------------------
_zbx_require_deps() {
  for cmd in curl jq; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      log_error "Missing dependency: $cmd. Run 'zbx doctor' for guidance."
      exit 127
    fi
  done
}

# ---- HTTP and auth helpers (unchanged from your version) --------------------
_zbx_curl_common() {
  local verify_opt=()
  if [ "${ZABBIX_VERIFY_TLS:-1}" -eq 0 ]; then
    verify_opt+=(--insecure)
  else
    # If custom CA is provided, point curl to it
    [ -n "${ZABBIX_CA_CERT:-}" ] && verify_opt+=(--cacert "$ZABBIX_CA_CERT")
    [ -n "${ZABBIX_CA_PATH:-}" ] && verify_opt+=(--capath "$ZABBIX_CA_PATH")
  fi
  curl -sS "${verify_opt[@]}" \
       --connect-timeout "${ZABBIX_CURL_TIMEOUT}" \
       --max-time "${ZABBIX_CURL_TIMEOUT}" \
       -H 'Content-Type: application/json' \
       "$@"
}

_zbx_read_session_token() {
  # Returns token string if present and not expired; empty otherwise
  local now ts tok path
  now="$(date +%s)"
  path="$ZABBIX_TOKEN_FILE"
  if [ -f "$path" ]; then
    # Try JSON format: {"token":"...","ts":123}
    if tok="$(jq -r 'try .token // empty' "$path" 2>/dev/null)" && [ -n "$tok" ]; then
      ts="$(jq -r 'try (.ts|tonumber) // 0' "$path" 2>/dev/null)"
      [ -z "$ts" ] && ts=0
      if [ $((ts + ZABBIX_SESSION_TTL)) -gt "$now" ]; then
        printf '%s' "$tok"; return 0
      else
        # expired
        return 0
      fi
    else
      # Legacy plain token file at configured path: treat as expired to force refresh
      return 0
    fi
  fi
  # Legacy fallback: prior default was a plain token in CWD
  if [ -f "./.zabbix_session.token" ]; then
    # Consider legacy tokens expired to enforce 30m lifetime and migrate on next login
    return 0
  fi
  return 0
}
_zbx_write_session_token() {
  # Never called when using API token; this stores session token + timestamp
  umask 077
  mkdir -p "$(dirname -- "$ZABBIX_TOKEN_FILE")" 2>/dev/null || true
  jq -n --arg t "$1" --argjson ts "$(date +%s)" '{token:$t, ts:$ts}' > "$ZABBIX_TOKEN_FILE".tmp
  mv "$ZABBIX_TOKEN_FILE".tmp "$ZABBIX_TOKEN_FILE"
}

zbx_login() {
  _zbx_require_deps
  if [ -n "${ZABBIX_API_TOKEN:-}" ]; then
    log_debug "Bearer token set; skipping user.login"
    return 0
  fi
  log_info "Logging into Zabbix as ${ZABBIX_USER}"
  local req resp tok
  req=$(jq -n --arg user "$ZABBIX_USER" --arg pass "$ZABBIX_PASS" \
        '{jsonrpc:"2.0", method:"user.login", id:1, params:{user:$user, password:$pass}}')
  if ! resp=$(_zbx_curl_common -X POST "$ZABBIX_URL" -d "$req"); then
    log_error "HTTP request failed during login. Check connectivity/TLS. Try 'zbx doctor'."
    return 1
  fi
  if ! jq -e . >/dev/null 2>&1 <<<"$resp"; then
    log_error "Unexpected non-JSON response from API. Check ZABBIX_URL/TLS. Try 'zbx doctor'."
    return 1
  fi
  tok=$(jq -r '.result // empty' <<<"$resp" || true)
  if [ -z "$tok" ]; then
    log_error "Zabbix login failed: $(jq -c '.error // {}' <<<"$resp")"
    log_info "Run 'zbx doctor' to diagnose common issues."
    return 1
  fi
  _zbx_write_session_token "$tok"
  log_debug "Session token cached"
}

zbx_call_raw() {
  _zbx_require_deps
  local method="$1"
  local params; params=$(cat || true); [ -z "${params:-}" ] && params='{}'

  # apiinfo.version must be called without Authorization/auth
  if [ "$method" = "apiinfo.version" ]; then
    local req
    req=$(jq -n --arg method "$method" --argjson params "$params" \
      '{jsonrpc:"2.0", method:$method, id:1, params:$params}')
    if ! _zbx_curl_common -X POST "$ZABBIX_URL" -d "$req"; then
      log_error "HTTP request failed calling $method. Check connectivity/TLS. Try 'zbx doctor'."
      return 1
    fi
    return 0
  fi

  local headers=() auth_field="null"
  if [ -n "${ZABBIX_API_TOKEN:-}" ]; then
    headers=(-H "Authorization: Bearer ${ZABBIX_API_TOKEN}")
  else
    local tok; tok="$(_zbx_read_session_token)"
    if [ -z "$tok" ]; then zbx_login; tok="$(_zbx_read_session_token)"; fi
    auth_field=$(jq -R <<<"$tok")
  fi

  local req
  req=$(jq -n --arg method "$method" --argjson params "$params" --argjson auth "$auth_field" '
    {jsonrpc:"2.0", method:$method, id:1, params:$params}
    | if $auth != null then .auth = $auth else . end
  ')
  if ! _zbx_curl_common -X POST "${headers[@]}" "$ZABBIX_URL" -d "$req"; then
    log_error "HTTP request failed calling $method. Check connectivity/TLS. Try 'zbx doctor'."
    return 1
  fi
}

zbx_call() {
  local method="$1" input resp
  input="$(cat || true)"
  resp=$(printf '%s' "$input" | zbx_call_raw "$method")
  if ! jq -e . >/dev/null 2>&1 <<<"$resp"; then
    log_error "Unexpected non-JSON response from API. Verify URL/TLS/auth. Try 'zbx doctor'."
    printf '%s' "$resp"
    return 1
  fi
  if [ -n "${ZABBIX_API_TOKEN:-}" ]; then printf '%s' "$resp"; return 0; fi
  if jq -e '.error.message? | test("Session terminated|Not authorised"; "i")' >/dev/null 2>&1 <<<"$resp"; then
    log_warn "Session terminated; re-login and retry once"
    zbx_login
    resp=$(printf '%s' "$input" | zbx_call_raw "$method")
  fi
  # If API returned a structured error, surface it with a hint
  if jq -e '.error? // empty' >/dev/null 2>&1 <<<"$resp"; then
    log_error "API error: $(jq -c '.error' <<<"$resp")"
    log_info "Run 'zbx doctor' to diagnose common issues."
  fi
  printf '%s' "$resp"
}

# Convenience: show where config came from
zbx_config_path() { printf '%s\n' "${ZBX_CONFIG_ACTIVE:-}"; }

# ---- Output formatting helpers ---------------------------------------------
# Usage: zbx_format_rows <format> <headers_json> <rows_json> [print_headers]
#   format: tsv|csv|json
#   headers_json: JSON array of column names (or '[]' for none)
#   rows_json: JSON array of arrays (rows)
#   print_headers: 1 to print header line for tsv/csv, 0 otherwise
# Notes:
#   - For json format: if print_headers==1 and headers are provided, emits an
#     array of objects by mapping headers to row fields; otherwise emits the raw
#     array-of-arrays.
zbx_format_rows() {
  local fmt="${1:-tsv}" headers="${2:-[]}" rows="${3:-[]}" want_hdrs="${4:-0}"
  case "$fmt" in
    json)
      if [ "$want_hdrs" -eq 1 ] && [ -n "$headers" ] && [ "$headers" != "[]" ]; then
        jq -c -n --argjson headers "$headers" --argjson rows "$rows" '
          [ $rows[] | with_entries(.key as $i | .value) |
            reduce range(0; ($headers|length)) as $i ({}; .[$headers[$i]] = (.["$i"])) ]
        '
      else
        jq -c -n --argjson rows "$rows" '$rows'
      fi
      ;;
    tsv|csv)
      local enc
      enc='@tsv'; [ "$fmt" = "csv" ] && enc='@csv'
      # headers
      if [ "$want_hdrs" -eq 1 ] && [ -n "$headers" ] && [ "$headers" != "[]" ]; then
        jq -r -n --argjson h "$headers" '$h | '"$enc"''
      fi
      # rows
      jq -r -n --argjson rows "$rows" '$rows[] | '"$enc"''
      ;;
    *)
      echo "Unsupported format: $fmt" >&2; return 2 ;;
  esac
}
